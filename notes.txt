----
records

type Doc = {
	code : String
	name : String
}

let d = { code = "1"; name = "a" }
let d2 = d |> { with code = "2" }
let d3 = { d with code = "3" }
let update = { with code = "2" }

type DocOfDoc = {
	doc : Doc
}

let dd = { doc = { code = "1"; name = "a" } }
let dd2 = { dd with doc.code = "2" }			// lensing

----
mutable

val x : Ref Int
let x = RefOf 1

x <- 2

// might want to add implicit conversion functions

----
type providers

@ TypeProvider
val provideCast : Type -> Type -> TypeProviderResult
let provideCast a b =
	// implementation

val cast : provideCast a b // cast : a -> b for a and b that are compatible
let cast x = (provideCast a b) x


let ints = [1; 2; 3]

val longs : List Long
let longs = ints |> map cast

--
or module providers?

// provided module would look like:
module castModule 'a 'b =
	type T = 'a -> 'b

	val cast : T
	let cast x = ...

val cast : castModule 'a 'b => 'a -> 'b
let cast = (castModule 'a 'b).cast

// then parametrization can be generalized to normal modules too
module MyModule 'a =
	type T = T 'a

	val bind : ('b -> 'c) -> (MyModule 'b).T -> (MyModule 'c).T
	let bind = ...

// this implies modules should not have mutable data

----
match as function?

val foo : Int -> String
let foo = match with
	| 0 -> "0"
	| 1 -> "1"
	| _ -> "many"

let foo x =
	match x with
	| 0 -> "none"
	| _ -> "some"

// "match <expr> with" is shorthand for "<expr> |> match with"
// curried form is allowed e. g. "match <expr1> <expr2> with"

----
generalized list syntax?

type MyType 'a =
	| Nil 
	| (::) : 'a -> MyType 'a -> MyType 'a

// automatically gets
val x : MyType Int
let x = [1; 2; 3]

----
no tuples, yes pairs
val t : (Int * Long * String)
// is shorthand for
val t : (Int * (Long * String))

----
implicit arguments

val foo : <'a:Type> -> 'a -> 'a

foo 1 // 'a = Int implicitely
foo <Int> 1 // explicit unnamed
foo <a=Int> 1 // explicit named

----
monadic computation

val async : // monadic type

let asyncInt = async#
	pure 1

let someM = (mkM 1)# pure 1

----
quotation

val expr : Expr (Int -> Int)
let expr = {@ \x -> x + 2 @}


----
wildcard in types

val lst : List _ // lst is List (Unit -> Int)
let lst = [
	\() -> 1
	\() -> 2
	\() -> 3
	]


----
type args

val foo : 'a -> 'b

val fooHigher : (''a -> ''b) -> 'a -> 'b


----
Overloaded literals and list constructors
let myNum : MyNumber = 1 // ?
let myCollection : MyCollection = 1 :: [] // ?


----
implicits can have implicit parameters

type Nextable T = T -> T

type Table T K V = {
	get : K -> T K V -> V
	set : K -> V -> T K V -> T K V
	}

type Iterable I A = I A -> Maybe (A, I A)

let iterableTable <T, K, V> *(table : Table T K V) *(next : Nextable K) : Iterable T V =
	\table ->
		// ok, bad example, but you get the idea
----

fact AreSame &a &b

module Maybe =
	type ^Maybe =
		| present a // pattern match emits: IsPresent <original_value>, AreSame (<original_value> .> deref) <extracted_value>
		| nothing

	fact IsPresent &a

	let isPresent &x : Maybe (Unit => IsPresent &x) =
		match x with
		| present x -> present ()
		| nothing -> nothing

	let deref <a> (&x : Maybe a) <_ : IsPressent &x> : a = ...

type Recur = { next : Maybe Recur }

let r = { next = present { next = present { next = nothing }}}

let list : List Recur = ...

let atLeast3Deep : List (r : Recur => IsPresent (r .> next), IsPresent (r .> next .> deref .> next), ...) =
	list
	.> map (\r ->
		match r .> next with
		| nothing -> nothing
		| present r2 -> // IsPresent (r .> next), AreSame (r .> next .> deref) r2 | emitted by successful match with "present"
			match r2 .> next with
			| nothing -> nothing
			| present r3 -> present r // + IsPresent (r2 .> next), AreSame (r2 .> next .> deref) r3, IsPresent (r .> next .> deref .> next), AreSame (r .> next .> deref .> next .> deref) r3
		) // List (Maybe (r : Recur => IsPresent (r .> next), IsPresent (r .> next .> deref .> next), ...))
	.> wherePresent id

let next r = r .> next .> deref // r : Recur => IsPresent (r .> next)
for r in atLeast3Deep do // r : Recur => IsPresent (r .> next), IsPresent (r .> next .> deref .> next), ...
	let r3 = r |> next |> next