module Kedr.ParserGenerator.Generator

open System.IO

//let private writeLine (str : string) (writer : StreamWriter) = writer.WriteLine(str)

let private writeLine str = sprintf str

let private writeComment (writer : StreamWriter) =
    [
    "//-----------------------------------------------------------------------"
    "// This code was generated by a tool."
    "// Changes to this file may cause incorrect behavior and will be lost if"
    "// the code is regenerated."
    "//-----------------------------------------------------------------------"
    ] |> Seq.iter writer.WriteLine

let private symbolToTypeVariable s =
    sprintf "'%s" (s.ToString())

let private typeVariableListOf symbols =
    symbols
    |> Seq.map symbolToTypeVariable
    |> Seq.sortDescending
    |> String.concat ", "

let private typeVariableMapOf symbols =
    symbols
    |> Seq.map (fun s -> (s, symbolToTypeVariable s))
    |> Map.ofSeq

let private writeTerminalType (grammar : Grammar<_>) writer =
    let typeVariableMap = typeVariableMapOf grammar.terminals
    let typeVariableList = typeVariableListOf grammar.terminals

    fprintfn writer "type Terminal<%s> =" typeVariableList

    seq {
        for terminal in grammar.terminals do
            let terminalStr = terminal.ToString()
            let typeVar = typeVariableMap.[terminal]
            sprintf "    | T_%s of %s" terminalStr typeVar
    }
    |> Seq.sort
    |> Seq.iter writer.WriteLine

let private writeReducerType (grammar : Grammar<_>) writer =
    let typeVariableMap = typeVariableMapOf grammar.symbols
    let typeVariableList = typeVariableListOf grammar.symbols

    fprintfn writer "type Reducer<%s> = {" typeVariableList

    seq {
        for production in grammar.productions do
            let fieldName =
                let fromString = production.from.ToString()
                let intoString = production.into |> Seq.map (fun s -> s.ToString()) |> String.concat "_"
                sprintf "%s_%s" fromString intoString

            let parameter =
                production.into
                |> Seq.map (fun s -> typeVariableMap.[s])
                |> String.concat " * "

            let result = typeVariableMap.[production.from]

            sprintf "    %s : (%s) -> %s" fieldName parameter result
    }
    |> Seq.sort
    |> Seq.iter writer.WriteLine

    fprintfn writer "}"

let private writeEitherType (grammar : Grammar<_>) writer =
    let typeVariableMap = typeVariableMapOf grammar.startingSymbols

    fprintfn writer "type Either<%s> =" (typeVariableListOf grammar.startingSymbols)

    seq {
        for symbol in grammar.startingSymbols do
            let symbolStr = symbol.ToString()
            let typeStr = typeVariableMap.[symbol]
            sprintf "    | E_%s of %s" symbolStr typeStr
    }
    |> Seq.sort
    |> Seq.iter writer.WriteLine

let private writeParseFunction (grammar : Grammar<_>) (automaton : LALR.Automaton<_>) writer =
    let symbolTypeVar =
        let occupiedNames = grammar.symbols |> Set.map symbolToTypeVariable
        let rec go name =
            if occupiedNames.Contains(name)
            then go (name + "_")
            else name
        go "'symbol"

    fprintfn writer "let parse<%s, %s>" symbolTypeVar (typeVariableListOf grammar.symbols)
    fprintfn writer "    (recognizeTerminal : %s -> Terminal<%s>)" symbolTypeVar (typeVariableListOf grammar.terminals)
    fprintfn writer "    (reducer : Reducer<%s>)" (typeVariableListOf grammar.symbols)
    fprintfn writer "    (symbols : seq<%s>)" symbolTypeVar

    let successResultType =
        if grammar.startingSymbols.Count = 1 then
            grammar.startingSymbols |> Seq.exactlyOne |> symbolToTypeVariable
        else
            let typeVarList = typeVariableListOf grammar.startingSymbols
            sprintf "Either<%s>" typeVarList
    fprintfn writer "    : Result<%s, string> =" successResultType
    fprintfn writer ""

    let orderedStates =
        automaton.states
        |> Seq.sortBy StableSorting.keyOfState
        |> List.ofSeq

    let startingSymbol =
        grammar.startingSymbols
        |> Seq.tryExactlyOne
        |> Option.defaultWith (fun () -> failwith "mutliple starting symbols are not supported")

    let startingState =
        automaton.states
        |> Seq.filter (fun st ->
            st.configurations
            |> Seq.exists (fun cfg ->
                cfg.production.from = startingSymbol &&
                cfg.cursorOffset = 0))
        |> Seq.exactlyOne

    fprintfn writer "    let mutable state = %i" (orderedStates |> List.findIndex ((=) startingState))
    fprintfn writer "    let mutable observedSymbol = Unchecked.defaultof<'symbol>"
    fprintfn writer "    let mutable observedSymbolIsEof = false"
    fprintfn writer "    let mutable lookaheadSymbol = Unchecked.defaultof<'symbol>"
    fprintfn writer "    let mutable lookaheadSymbolIsEof = false"
    fprintfn writer "    use enumerator = symbols.GetEnumerator()"
    fprintfn writer "    let shift () ="
    fprintfn writer "        observedSymbol <- lookaheadSymbol"
    fprintfn writer "        observedSymbolIsEof <- lookaheadSymbolIsEof"
    fprintfn writer "        if not lookaheadSymbolIsEof then"
    fprintfn writer "            if enumerator.MoveNext()"
    fprintfn writer "            then lookaheadSymbol <- enumerator.Current"
    fprintfn writer "            else lookaheadSymbolIsEof <- true"
    fprintfn writer "    shift ()"
    fprintfn writer "    shift ()"
    fprintfn writer "    match state with"
    for (i, state) in orderedStates |> Seq.indexed do
        fprintfn writer "    | %i -> ()" i
    fprintfn writer "    | _ -> failwith \"parser is in an invalid state\""

    fprintfn writer "    failwith \"TODO\""

let generate (eof : 's) (grammar : Grammar<'s>) (parserFullName : string) (stream : Stream) : unit =
    let automaton = LALR.Automaton.create eof grammar

    let writer = new StreamWriter(stream)

    writeComment writer

    fprintfn writer "module internal rec %s" parserFullName
    fprintfn writer ""

    writeTerminalType grammar writer
    fprintfn writer ""

    writeReducerType grammar writer
    fprintfn writer ""

    if grammar.startingSymbols.Count > 1 then
        writeEitherType grammar writer
        fprintfn writer ""

    writeParseFunction grammar automaton writer

    writer.Flush()

    ()