module Kedr.ParserGenerator.Generator

open System.IO

//let private writeLine (str : string) (writer : StreamWriter) = writer.WriteLine(str)

let private writeLine str = sprintf str

let private writeComment (writer : StreamWriter) =
    [
    "//-----------------------------------------------------------------------"
    "// This code was generated by a tool."
    "// Changes to this file may cause incorrect behavior and will be lost if"
    "// the code is regenerated."
    "//-----------------------------------------------------------------------"
    ] |> Seq.iter writer.WriteLine

let private symbolToTypeVariable s =
    sprintf "'%s" (s.ToString())

let private typeVariableListOf symbols =
    symbols
    |> Seq.map symbolToTypeVariable
    |> Seq.sortDescending
    |> String.concat ", "

let private typeVariableMapOf symbols =
    symbols
    |> Seq.map (fun s -> (s, symbolToTypeVariable s))
    |> Map.ofSeq

let private writeTerminalType (grammar : Grammar<_>) writer =
    let typeVariableMap = typeVariableMapOf grammar.terminals
    let typeVariableList = typeVariableListOf grammar.terminals

    fprintfn writer "type Terminal<%s> =" typeVariableList

    seq {
        for terminal in grammar.terminals do
            let terminalStr = terminal.ToString()
            let typeVar = typeVariableMap.[terminal]
            sprintf "    | T_%s of %s" terminalStr typeVar
    }
    |> Seq.sort
    |> Seq.iter writer.WriteLine

let private writeReducerType (grammar : Grammar<_>) writer =
    let typeVariableMap = typeVariableMapOf grammar.symbols
    let typeVariableList = typeVariableListOf grammar.symbols

    fprintfn writer "type Reducer<%s> = {" typeVariableList

    seq {
        for production in grammar.productions do
            let fieldName =
                let fromString = production.from.ToString()
                let intoString = production.into |> Seq.map (fun s -> s.ToString()) |> String.concat "_"
                sprintf "%s_%s" fromString intoString

            let parameter =
                production.into
                |> Seq.map (fun s -> typeVariableMap.[s])
                |> String.concat " * "

            let result = typeVariableMap.[production.from]

            sprintf "    %s : (%s) -> %s" fieldName parameter result
    }
    |> Seq.sort
    |> Seq.iter writer.WriteLine

    fprintfn writer "}"

let private writeEitherType (grammar : Grammar<_>) writer =
    let typeVariableMap = typeVariableMapOf grammar.startingSymbols

    fprintfn writer "type Either<%s> =" (typeVariableListOf grammar.startingSymbols)

    seq {
        for symbol in grammar.startingSymbols do
            let symbolStr = symbol.ToString()
            let typeStr = typeVariableMap.[symbol]
            sprintf "    | E_%s of %s" symbolStr typeStr
    }
    |> Seq.sort
    |> Seq.iter writer.WriteLine

let private writeParseFunction (grammar : Grammar<_>) writer =
    let tokenTypeVar =
        let occupiedNames = grammar.symbols |> Set.map symbolToTypeVariable
        let rec go name =
            if occupiedNames.Contains(name)
            then go (name + "_")
            else name
        go "'token"

    fprintfn writer "let parse<%s, %s>" tokenTypeVar (typeVariableListOf grammar.symbols)
    fprintfn writer "    (recognizeTerminal : %s -> Terminal<%s>)" tokenTypeVar (typeVariableListOf grammar.terminals)
    fprintfn writer "    (reducer : Reducer<%s>)" (typeVariableListOf grammar.symbols)
    fprintfn writer "    (tokens : seq<%s>)" tokenTypeVar

    let successResultType =
        if grammar.startingSymbols.Count = 1 then
            grammar.startingSymbols |> Seq.exactlyOne |> symbolToTypeVariable
        else
            let typeVarList = typeVariableListOf grammar.startingSymbols
            sprintf "Either<%s>" typeVarList
    fprintfn writer "    : Result<%s, string> =" successResultType

    fprintfn writer "    failwith \"TODO\""

let generate (eof : 's) (grammar : Grammar<'s>) (parserFullName : string) (stream : Stream) : unit =
    let automaton = LALR.Automaton.create eof grammar

    let writer = new StreamWriter(stream)

    writeComment writer

    fprintfn writer "module internal rec %s" parserFullName
    fprintfn writer ""

    writeTerminalType grammar writer
    fprintfn writer ""

    writeReducerType grammar writer
    fprintfn writer ""

    if grammar.startingSymbols.Count > 1 then
        writeEitherType grammar writer
        fprintfn writer ""

    writeParseFunction grammar writer

    writer.Flush()

    ()