module internal Kedr.ParserGenerator.CodeGen.CodeGenerator

open Kedr.ParserGenerator.LALR

#nowarn "0058"

open Kedr.ParserGenerator
open Kedr.ParserGenerator.CodeGen.Code
open System.IO

let private comment str = Line $"// %s{str}"

let private blankLine = Line ""

let private header = code {
    comment "---------------------------------------------------------------------"
    comment "This code was generated by a tool."
    comment "Changes to this file may cause incorrect behavior and will be lost if"
    comment "the code is regenerated."
    comment "---------------------------------------------------------------------"
}

let private moduleDecl name = Line $"module internal %s{name}"

let private sumTypeDecl name cases = code {
    Line $"type %s{name} ="
    Indented <| code {
        for (name, type_) in cases do
            Line $"| %s{name} of (%s{type_})"
    }
}

let private recordDecl name fields = code {
    let fieldLine (name, type_) = Line $"%s{name} : %s{type_}"

    Line $"type %s{name} = {{"
    Indented (Block (fields |> List.map fieldLine))
    Line "}"
}

type CodeGenArgs<'s when 's : comparison> =
    { newLine : string
      eofSymbol : 's
      symbolTypes : Map<'s, string>
      symbolToIdentifier : 's -> string
      parsingTable : ParsingTable<'s>
      parserModuleName : string }

let private symbolToTerminalCase args s = "T_" + (args.symbolToIdentifier s)

let private productionToReducerFieldName args production =
    let from = args.symbolToIdentifier production.from
    let into =
        production.into
        |> Seq.map args.symbolToIdentifier
        |> String.concat "_"

    $"{from}_{into}"

let private reducerType args =
    let reducerFields =
        args.parsingTable.grammar.productions
        |> Seq.map (fun p ->
            let name = productionToReducerFieldName args p

            let type_ =
                let argType =
                    p.into
                    |> Seq.map (fun s -> "(" + args.symbolTypes.[s] + ")")
                    |> String.concat " * "
                let resultType = args.symbolTypes.[p.from]

                $"{argType} -> {resultType}"

            (name, type_))
        |> Seq.sort
        |> List.ofSeq

    recordDecl "Reducer" reducerFields

let private failwithInvalidState = "failwith \"Parser is in an invalid state. This is a bug in the parser generator.\""

let private parseFunction args terminalCases = code {
    let actionTable = args.parsingTable.action
    let gotoTable = args.parsingTable.goto
    let grammar = args.parsingTable.grammar

    let startingSymbolType = args.symbolTypes.[grammar.startingSymbol]

    let states =
        actionTable
        |> Map.toList
        |> List.map fst

    let stateNumbers =
        states
        |> Seq.mapi (fun i state -> (state, i))
        |> Map.ofSeq

    let startingState =
        states
        |> Seq.find (fun state ->
            state.configurations
            |> Seq.exists (fun cfg ->
                cfg.production.from = grammar.startingSymbol &&
                cfg |> Configuration.isStarting))

    Line $"let parse (reducer : Reducer) (input : Terminal seq) : Result<{startingSymbolType}, string> ="
    Indented <| code {
        Line "use inputEnumerator = input.GetEnumerator()"
        Line "let lhsStack = System.Collections.Generic.Stack<obj>(50)"
        Line "let stateStack = System.Collections.Generic.Stack<int>(50)"
        Line $"let mutable result = Unchecked.defaultof<{startingSymbolType}>"
        Line "let mutable accepted = false"
        blankLine
        Line $"stateStack.Push({stateNumbers.[startingState]})"
        blankLine
//        Line "let mutable lookaheadIsEof = false"
        Line "let mutable (lookahead, lookaheadIsEof) ="
        Indented <| code {
            Line "if inputEnumerator.MoveNext()"
            Line "then (inputEnumerator.Current, false)"
            Line "else (Unchecked.defaultof<Terminal>, true)"
        }
        blankLine
        Line "let mutable keepGoing = true"
        Line "while keepGoing do"
        Indented <| code {
            Line "match stateStack.Peek() with"
            for (state, stateActions) in actionTable |> Map.toSeq do
                Line $"| {stateNumbers.[state]} ->"
                Indented <| code {
                    Line "match lookahead with"

                    let stateActions =
                        stateActions
                        |> Map.toSeq
                        |> Seq.sortBy (fun (s, _) -> if s = args.eofSymbol then 0 else 1)

                    for (symbol, action) in stateActions do
                        match action with
                        | Shift newState ->
                            Line $"| {symbolToTerminalCase args symbol} x ->"
                            Indented <| code {
                                comment "shift"
                                Line "lhsStack.Push(x)"
                                Line "if inputEnumerator.MoveNext()"
                                Line "then lookahead <- inputEnumerator.Current"
                                Line "else lookaheadIsEof <- true"
                                Line $"stateStack.Push({stateNumbers.[newState]})"
                            }
                        | Reduce production ->
                            let reductionArgs =
                                production.into
                                |> Seq.mapi (fun i s -> ($"arg{i + 1}", args.symbolTypes.[s]) )
                                |> List.ofSeq

                            let argList =
                                reductionArgs
                                |> Seq.map fst
                                |> String.concat ", "

                            if symbol <> args.eofSymbol
                            then Line $"| {symbolToTerminalCase args symbol} _ ->"
                            else Line $"| _ when lookaheadIsEof ->"
                            Indented <| code {
                                comment "reduce"
                                for (argName, argType) in reductionArgs |> List.rev do
                                    Line $"let {argName} = lhsStack.Pop() :?> {argType}"
                                    Line "stateStack.Pop() |> ignore"
                                Line $"let reductionArgs = ({argList})"
                                Line $"let reduced = reducer.{productionToReducerFieldName args production} reductionArgs"
                                Line "lhsStack.Push(reduced)"
                                Line "let nextState = "
                                Indented <| code {
                                    Line "match stateStack.Peek() with"
                                    let gotoFlat =
                                        gotoTable
                                        |> Map.toSeq
                                        |> Seq.collect (fun (state, stateGoto) ->
                                            stateGoto
                                            |> Map.toSeq
                                            |> Seq.filter (fun (s, _) -> s = production.from)
                                            |> Seq.map (fun (_, dest) -> (state, dest)))
                                        |> List.ofSeq
                                    for (src, dest) in gotoFlat do
                                        Line $"| {stateNumbers.[src]} -> {stateNumbers.[dest]}"
                                    Line $"| _ -> {failwithInvalidState}"
                                }
                                Line "stateStack.Push(nextState)"
                            }
                        | Accept ->
                            if symbol <> args.eofSymbol then failwith "Accept on non eof"

                            Line $"| _ when lookaheadIsEof ->"
                            Indented <| code {
                                comment "accept"
                                Line $"result <- lhsStack.Pop() :?> {startingSymbolType}"
                                Line "accepted <- true"
                                Line "keepGoing <- false"
                            }
                    Line "| _ ->"
                    Indented <| code {
                        comment "error"
                        Line "keepGoing <- false"
                    }
                }
            Line $"| _ -> {failwithInvalidState}"
        }
        blankLine
        Line "if accepted"
        Line "then Ok result"
        Line "else Error \"TODO error reporting\""
    }
}

let generate (args : CodeGenArgs<'s>) (stream : Stream) : unit =
    let writer = new StreamWriter(stream)

    let terminalCases =
        args.parsingTable.grammar.terminals
        |> Seq.map (fun t ->
            let name = "T_" + (args.symbolToIdentifier t)
            let type_ = args.symbolTypes |> Map.find t
            (name, type_))
        |> Seq.sort
        |> List.ofSeq

    let parserCode =
        code {
            header
            moduleDecl args.parserModuleName
            blankLine
            sumTypeDecl "Terminal" terminalCases
            blankLine
            reducerType args
            blankLine
            parseFunction args terminalCases
        }

    parserCode |> write args.newLine writer

    writer.Flush()