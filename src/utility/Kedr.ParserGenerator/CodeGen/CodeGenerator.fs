module internal Kedr.ParserGenerator.CodeGen.CodeGenerator

open Kedr.ParserGenerator.LALR

#nowarn "0058"

open Kedr.ParserGenerator
open Kedr.ParserGenerator.CodeGen.Code
open System.IO

let private comment str = Line $"// %s{str}"

let private blankLine = Line ""

let private header = code {
    comment "---------------------------------------------------------------------"
    comment "This code was generated by a tool."
    comment "Changes to this file may cause incorrect behavior and will be lost if"
    comment "the code is regenerated."
    comment "---------------------------------------------------------------------"
}

let private moduleDecl name = Line $"module internal %s{name}"

let private sumTypeDecl name cases = code {
    Line $"type %s{name} ="
    Indented <| code {
        for (name, type_) in cases do
            Line $"| %s{name} of (%s{type_})"
    }
}

let private recordDecl name fields = code {
    let fieldLine (name, type_) = Line $"%s{name} : %s{type_}"

    Line $"type %s{name} = {{"
    Indented (Block (fields |> List.map fieldLine))
    Line "}"
}

type CodeGenArgs<'s when 's : comparison> =
    { newLine : string
      eofSymbol : 's
      symbolTypes : Map<'s, string>
      symbolToIdentifier : 's -> string
      parsingTable : ParsingTable<'s>
      parserModuleName : string }

let private symbolToTerminalCase args s = "T_" + (args.symbolToIdentifier s)

let private reducerType args =
    let reducerFields =
        args.parsingTable.grammar.productions
        |> Seq.map (fun p ->
            let name =
                let from = args.symbolToIdentifier p.from
                let into =
                    p.into
                    |> Seq.map args.symbolToIdentifier
                    |> String.concat "_"

                $"{from}_{into}"

            let type_ =
                let argType =
                    p.into
                    |> Seq.map (fun s -> "(" + args.symbolTypes.[s] + ")")
                    |> String.concat " * "
                let resultType = args.symbolTypes.[p.from]

                $"{argType} -> {resultType}"

            (name, type_))
        |> Seq.sort
        |> List.ofSeq

    recordDecl "Reducer" reducerFields

let private failwithInvalidState = "failwith \"Parser is in an invalid state. This is a bug in the parser generator.\""

let private parseFunction args terminalCases = code {
    let actionTable = args.parsingTable.action
    let gotoTable = args.parsingTable.goto
    let grammar = args.parsingTable.grammar

    let startingSymbolType = args.symbolTypes.[grammar.startingSymbol]

    let states =
        actionTable
        |> Map.toList
        |> List.map fst

    let stateNumbers =
        states
        |> Seq.mapi (fun i state -> (state, i))
        |> Map.ofSeq

    let startingState =
        states
        |> Seq.find (fun state ->
            state.configurations
            |> Seq.exists (fun cfg ->
                cfg.production.from = grammar.startingSymbol &&
                cfg |> Configuration.isStarting))

    Line $"let parse (reducer : Reducer) (input : Terminal seq) : Result<{startingSymbolType}, string> ="
    Indented <| code {
        Line "use inputEnumerator = input.GetEnumerator()"
        Line $"let mutable state = {stateNumbers.[startingState]}"
        Line "let eof = Unchecked.defaultof<Terminal>"
        Line "let lhsStack = System.Collections.Generic.Stack<obj>(50)"
        Line "let stateStack = System.Collections.Generic.Stack<int>(50)"
        Line "let mutable lookahead = Unchecked.defaultof<Terminal>"
        Line $"let mutable result = Unchecked.defaultof<{startingSymbolType}>"
        Line "let mutable accepted = false"
        Line "let mutable keepGoing = true"
        blankLine
        Line "lookahead <-"
        Indented <| code {
            Line "if inputEnumerator.MoveNext()"
            Line "then inputEnumerator.Current"
            Line "else eof"
        }
        blankLine
        Line "while keepGoing do"
        Indented <| code {
            Line "match state with"
            code {
                for (state, stateActions) in actionTable |> Map.toSeq do
                    Line $"| {stateNumbers.[state]} ->"
                    Indented <| code {
                        Line "match lookahead with"
                        for (symbol, action) in stateActions |> Map.toSeq do
                            if symbol <> args.eofSymbol
                            then Line $"| {symbolToTerminalCase args symbol} x ->"
                            else Line $"| t when t = eof ->"
                            Indented <| code {
                                match action with
                                | Shift newState ->
                                    comment "shift"
                                    Line "lhsStack.Push(x)"
                                    Line "lookahead <-"
                                    Indented <| code {
                                        Line "if inputEnumerator.MoveNext()"
                                        Line "then inputEnumerator.Current"
                                        Line "else eof"
                                    }
                                    Line $"state <- {stateNumbers.[newState]}"
                                | Reduce production ->
                                    let args =
                                        [1..production.into.Length]
                                        |> List.map (sprintf "arg%i")

                                    for arg in args |> List.rev do
                                        Line $"let {arg} = lhsStack.Pop()"

                                    let argList = args |> String.concat ", "
                                    Line $"let reductionArgs = ({argList})"
                                    Line "()"
                                | Accept ->
                                    comment "accept"
                                    Line "accepted <- true"
                                    Line "keepGoing <- false"
                            }
                    }
                Line $"| _ -> {failwithInvalidState}"
            }
        }
        blankLine
        Line "if accepted"
        Line "then Ok result"
        Line "else Error \"TODO error reporting\""
    }
}

let generate (args : CodeGenArgs<'s>) (stream : Stream) : unit =
    let writer = new StreamWriter(stream)

    let terminalCases =
        args.parsingTable.grammar.terminals
        |> Seq.map (fun t ->
            let name = "T_" + (args.symbolToIdentifier t)
            let type_ = args.symbolTypes |> Map.find t
            (name, type_))
        |> Seq.sort
        |> List.ofSeq

    let parserCode =
        code {
            header
            moduleDecl args.parserModuleName
            blankLine
            sumTypeDecl "Terminal" terminalCases
            blankLine
            reducerType args
            blankLine
            parseFunction args terminalCases
        }

    parserCode |> write args.newLine writer

    writer.Flush()