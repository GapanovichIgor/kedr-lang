// ---------------------------------------------------------------------
// This code was generated by a tool.
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
// ---------------------------------------------------------------------
module internal Kedr.AST.ParserImpl

type Terminal =
    | T_id of (string)
    | T_numlit of (uint32 * uint32 option)
    | T_parenc of (unit)
    | T_pareno of (unit)
    | T_strlit of (string)

type Reducer = {
    EXPR_id : (string) -> Expr
    EXPR_numlit : (uint32 * uint32 option) -> Expr
    EXPR_pareno_EXPR_parenc : (unit) * (Expr) * (unit) -> Expr
    EXPR_strlit : (string) -> Expr
    S_EXPR : (Expr) -> Expr
}

let parse (reducer : Reducer) (input : Terminal seq) : Result<Expr, string> =
    use inputEnumerator = input.GetEnumerator()
    let lhsStack = System.Collections.Generic.Stack<obj>(50)
    let stateStack = System.Collections.Generic.Stack<int>(50)
    let mutable result = Unchecked.defaultof<Expr>
    let mutable accepted = false

    stateStack.Push(1)

    let mutable (lookahead, lookaheadIsEof) =
        if inputEnumerator.MoveNext()
        then (inputEnumerator.Current, false)
        else (Unchecked.defaultof<Terminal>, true)

    let mutable keepGoing = true
    while keepGoing do
        match stateStack.Peek() with
        | 0 ->
            match lookahead with
            | T_id x ->
                // shift
                lhsStack.Push(x)
                if inputEnumerator.MoveNext()
                then lookahead <- inputEnumerator.Current
                else lookaheadIsEof <- true
                stateStack.Push(2)
            | T_numlit x ->
                // shift
                lhsStack.Push(x)
                if inputEnumerator.MoveNext()
                then lookahead <- inputEnumerator.Current
                else lookaheadIsEof <- true
                stateStack.Push(3)
            | T_pareno x ->
                // shift
                lhsStack.Push(x)
                if inputEnumerator.MoveNext()
                then lookahead <- inputEnumerator.Current
                else lookaheadIsEof <- true
                stateStack.Push(0)
            | T_strlit x ->
                // shift
                lhsStack.Push(x)
                if inputEnumerator.MoveNext()
                then lookahead <- inputEnumerator.Current
                else lookaheadIsEof <- true
                stateStack.Push(6)
            | _ ->
                // error
                keepGoing <- false
        | 1 ->
            match lookahead with
            | T_id x ->
                // shift
                lhsStack.Push(x)
                if inputEnumerator.MoveNext()
                then lookahead <- inputEnumerator.Current
                else lookaheadIsEof <- true
                stateStack.Push(2)
            | T_numlit x ->
                // shift
                lhsStack.Push(x)
                if inputEnumerator.MoveNext()
                then lookahead <- inputEnumerator.Current
                else lookaheadIsEof <- true
                stateStack.Push(3)
            | T_pareno x ->
                // shift
                lhsStack.Push(x)
                if inputEnumerator.MoveNext()
                then lookahead <- inputEnumerator.Current
                else lookaheadIsEof <- true
                stateStack.Push(0)
            | T_strlit x ->
                // shift
                lhsStack.Push(x)
                if inputEnumerator.MoveNext()
                then lookahead <- inputEnumerator.Current
                else lookaheadIsEof <- true
                stateStack.Push(6)
            | _ ->
                // error
                keepGoing <- false
        | 2 ->
            match lookahead with
            | _ when lookaheadIsEof ->
                // reduce
                let arg1 = lhsStack.Pop() :?> string
                stateStack.Pop() |> ignore
                let reductionArgs = (arg1)
                let reduced = reducer.EXPR_id reductionArgs
                lhsStack.Push(reduced)
                let nextState = 
                    match stateStack.Peek() with
                    | 0 -> 4
                    | 1 -> 7
                    | _ -> failwith "Parser is in an invalid state. This is a bug in the parser generator."
                stateStack.Push(nextState)
            | T_parenc _ ->
                // reduce
                let arg1 = lhsStack.Pop() :?> string
                stateStack.Pop() |> ignore
                let reductionArgs = (arg1)
                let reduced = reducer.EXPR_id reductionArgs
                lhsStack.Push(reduced)
                let nextState = 
                    match stateStack.Peek() with
                    | 0 -> 4
                    | 1 -> 7
                    | _ -> failwith "Parser is in an invalid state. This is a bug in the parser generator."
                stateStack.Push(nextState)
            | _ ->
                // error
                keepGoing <- false
        | 3 ->
            match lookahead with
            | _ when lookaheadIsEof ->
                // reduce
                let arg1 = lhsStack.Pop() :?> uint32 * uint32 option
                stateStack.Pop() |> ignore
                let reductionArgs = (arg1)
                let reduced = reducer.EXPR_numlit reductionArgs
                lhsStack.Push(reduced)
                let nextState = 
                    match stateStack.Peek() with
                    | 0 -> 4
                    | 1 -> 7
                    | _ -> failwith "Parser is in an invalid state. This is a bug in the parser generator."
                stateStack.Push(nextState)
            | T_parenc _ ->
                // reduce
                let arg1 = lhsStack.Pop() :?> uint32 * uint32 option
                stateStack.Pop() |> ignore
                let reductionArgs = (arg1)
                let reduced = reducer.EXPR_numlit reductionArgs
                lhsStack.Push(reduced)
                let nextState = 
                    match stateStack.Peek() with
                    | 0 -> 4
                    | 1 -> 7
                    | _ -> failwith "Parser is in an invalid state. This is a bug in the parser generator."
                stateStack.Push(nextState)
            | _ ->
                // error
                keepGoing <- false
        | 4 ->
            match lookahead with
            | T_parenc x ->
                // shift
                lhsStack.Push(x)
                if inputEnumerator.MoveNext()
                then lookahead <- inputEnumerator.Current
                else lookaheadIsEof <- true
                stateStack.Push(5)
            | _ ->
                // error
                keepGoing <- false
        | 5 ->
            match lookahead with
            | _ when lookaheadIsEof ->
                // reduce
                let arg3 = lhsStack.Pop() :?> unit
                stateStack.Pop() |> ignore
                let arg2 = lhsStack.Pop() :?> Expr
                stateStack.Pop() |> ignore
                let arg1 = lhsStack.Pop() :?> unit
                stateStack.Pop() |> ignore
                let reductionArgs = (arg1, arg2, arg3)
                let reduced = reducer.EXPR_pareno_EXPR_parenc reductionArgs
                lhsStack.Push(reduced)
                let nextState = 
                    match stateStack.Peek() with
                    | 0 -> 4
                    | 1 -> 7
                    | _ -> failwith "Parser is in an invalid state. This is a bug in the parser generator."
                stateStack.Push(nextState)
            | T_parenc _ ->
                // reduce
                let arg3 = lhsStack.Pop() :?> unit
                stateStack.Pop() |> ignore
                let arg2 = lhsStack.Pop() :?> Expr
                stateStack.Pop() |> ignore
                let arg1 = lhsStack.Pop() :?> unit
                stateStack.Pop() |> ignore
                let reductionArgs = (arg1, arg2, arg3)
                let reduced = reducer.EXPR_pareno_EXPR_parenc reductionArgs
                lhsStack.Push(reduced)
                let nextState = 
                    match stateStack.Peek() with
                    | 0 -> 4
                    | 1 -> 7
                    | _ -> failwith "Parser is in an invalid state. This is a bug in the parser generator."
                stateStack.Push(nextState)
            | _ ->
                // error
                keepGoing <- false
        | 6 ->
            match lookahead with
            | _ when lookaheadIsEof ->
                // reduce
                let arg1 = lhsStack.Pop() :?> string
                stateStack.Pop() |> ignore
                let reductionArgs = (arg1)
                let reduced = reducer.EXPR_strlit reductionArgs
                lhsStack.Push(reduced)
                let nextState = 
                    match stateStack.Peek() with
                    | 0 -> 4
                    | 1 -> 7
                    | _ -> failwith "Parser is in an invalid state. This is a bug in the parser generator."
                stateStack.Push(nextState)
            | T_parenc _ ->
                // reduce
                let arg1 = lhsStack.Pop() :?> string
                stateStack.Pop() |> ignore
                let reductionArgs = (arg1)
                let reduced = reducer.EXPR_strlit reductionArgs
                lhsStack.Push(reduced)
                let nextState = 
                    match stateStack.Peek() with
                    | 0 -> 4
                    | 1 -> 7
                    | _ -> failwith "Parser is in an invalid state. This is a bug in the parser generator."
                stateStack.Push(nextState)
            | _ ->
                // error
                keepGoing <- false
        | 7 ->
            match lookahead with
            | _ when lookaheadIsEof ->
                // accept
                result <- lhsStack.Pop() :?> Expr
                accepted <- true
                keepGoing <- false
            | _ ->
                // error
                keepGoing <- false
        | _ -> failwith "Parser is in an invalid state. This is a bug in the parser generator."

    if accepted
    then Ok result
    else Error "TODO error reporting"
