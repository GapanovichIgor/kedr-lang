// ---------------------------------------------------------------------
// This code was generated by a tool.
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
// ---------------------------------------------------------------------
module internal Kedr.AST.ParserImpl

type Terminal =
    | T_id of (string)
    | T_numlit of (uint32 * uint32 option)
    | T_parenc of (unit)
    | T_pareno of (unit)
    | T_strlit of (string)

type Reducer = {
    EXPR_id : (string) -> Expr
    EXPR_numlit : (uint32 * uint32 option) -> Expr
    EXPR_pareno_EXPR_parenc : (unit) * (Expr) * (unit) -> Expr
    EXPR_strlit : (string) -> Expr
    S_EXPR : (Expr) -> Expr
}

let parse (reducer : Reducer) (input : Terminal seq) : Result<Expr, string> =
    use inputEnumerator = input.GetEnumerator()
    let mutable state = 1
    let eof = Unchecked.defaultof<Terminal>
    let lhsStack = System.Collections.Generic.Stack<obj>(50)
    let stateStack = System.Collections.Generic.Stack<int>(50)
    let mutable lookahead = Unchecked.defaultof<Terminal>
    let mutable result = Unchecked.defaultof<Expr>
    let mutable accepted = false
    let mutable keepGoing = true

    lookahead <-
        if inputEnumerator.MoveNext()
        then inputEnumerator.Current
        else eof

    while keepGoing do
        match state with
        | 0 ->
            match lookahead with
            | T_id x ->
                // shift
                lhsStack.Push(x)
                lookahead <-
                    if inputEnumerator.MoveNext()
                    then inputEnumerator.Current
                    else eof
                state <- 2
            | T_numlit x ->
                // shift
                lhsStack.Push(x)
                lookahead <-
                    if inputEnumerator.MoveNext()
                    then inputEnumerator.Current
                    else eof
                state <- 3
            | T_pareno x ->
                // shift
                lhsStack.Push(x)
                lookahead <-
                    if inputEnumerator.MoveNext()
                    then inputEnumerator.Current
                    else eof
                state <- 0
            | T_strlit x ->
                // shift
                lhsStack.Push(x)
                lookahead <-
                    if inputEnumerator.MoveNext()
                    then inputEnumerator.Current
                    else eof
                state <- 6
        | 1 ->
            match lookahead with
            | T_id x ->
                // shift
                lhsStack.Push(x)
                lookahead <-
                    if inputEnumerator.MoveNext()
                    then inputEnumerator.Current
                    else eof
                state <- 2
            | T_numlit x ->
                // shift
                lhsStack.Push(x)
                lookahead <-
                    if inputEnumerator.MoveNext()
                    then inputEnumerator.Current
                    else eof
                state <- 3
            | T_pareno x ->
                // shift
                lhsStack.Push(x)
                lookahead <-
                    if inputEnumerator.MoveNext()
                    then inputEnumerator.Current
                    else eof
                state <- 0
            | T_strlit x ->
                // shift
                lhsStack.Push(x)
                lookahead <-
                    if inputEnumerator.MoveNext()
                    then inputEnumerator.Current
                    else eof
                state <- 6
        | 2 ->
            match lookahead with
            | t when t = eof ->
                let arg1 = lhsStack.Pop()
                let reductionArgs = (arg1)
                ()
            | T_parenc x ->
                let arg1 = lhsStack.Pop()
                let reductionArgs = (arg1)
                ()
        | 3 ->
            match lookahead with
            | t when t = eof ->
                let arg1 = lhsStack.Pop()
                let reductionArgs = (arg1)
                ()
            | T_parenc x ->
                let arg1 = lhsStack.Pop()
                let reductionArgs = (arg1)
                ()
        | 4 ->
            match lookahead with
            | T_parenc x ->
                // shift
                lhsStack.Push(x)
                lookahead <-
                    if inputEnumerator.MoveNext()
                    then inputEnumerator.Current
                    else eof
                state <- 5
        | 5 ->
            match lookahead with
            | t when t = eof ->
                let arg3 = lhsStack.Pop()
                let arg2 = lhsStack.Pop()
                let arg1 = lhsStack.Pop()
                let reductionArgs = (arg1, arg2, arg3)
                ()
            | T_parenc x ->
                let arg3 = lhsStack.Pop()
                let arg2 = lhsStack.Pop()
                let arg1 = lhsStack.Pop()
                let reductionArgs = (arg1, arg2, arg3)
                ()
        | 6 ->
            match lookahead with
            | t when t = eof ->
                let arg1 = lhsStack.Pop()
                let reductionArgs = (arg1)
                ()
            | T_parenc x ->
                let arg1 = lhsStack.Pop()
                let reductionArgs = (arg1)
                ()
        | 7 ->
            match lookahead with
            | t when t = eof ->
                // accept
                accepted <- true
                keepGoing <- false
        | _ -> failwith "Parser is in an invalid state. This is a bug in the parser generator."

    if accepted
    then Ok result
    else Error "TODO error reporting"
